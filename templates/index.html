<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GPX Viewer with Track Stats</title>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>

<style>
html, body {
    margin: 0;
    height: 100%;
    font-family: Arial, sans-serif;
}
#map {
    height: 50%;
    width: 100%;
}
#stats {
    padding: 10px;
    background: #f5f5f5;
}
#stats p {
    margin: 5px 0;
    font-size: 12px;
}
#chart-container {
    height: 35%;
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
}
</style>
</head>
<body>

<div id="map"></div>

<div id="stats">
    <p id="total-distance">Total Distance:</p>
    <p id="total-ascent">Total Ascent:</p>
    <p id="total-descent">Total Descent:</p>
    <p id="min-elevation">Min Elevation:</p>
    <p id="max-elevation">Max Elevation:</p>
    <p id="avg-slope">Average Slope:</p>
    <input type="file" id="route" accept=".gpx">
</div>

<div id="chart-container">
    <canvas id="elevationChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gpx-parse@0.10.4/dist/gpx-parse-browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
const map = L.map('map').setView([0, 0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap'
}).addTo(map);

let polyline = null;
let hoverMarker = null;
let elevationChart = null;

function loadGpxFromText(gpxText) {
    gpxParse.parseGpx(gpxText, function (error, data) {
        if (error || !data.tracks.length) return;

        // CLEAR OLD DATA
        if (polyline) map.removeLayer(polyline);
        if (hoverMarker) map.removeLayer(hoverMarker);
        if (elevationChart) elevationChart.destroy();

        const track = data.tracks[0];
        let trackPoints = [];
        let cumulativeDistance = 0;
        let cumulativeAscent = 0;
        let cumulativeDescent = 0;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        let slopeSum = 0;
        let slopeCount = 0;
        let prevPoint = null;

        track.segments.forEach(segment => {
            segment.forEach(p => {
                const point = {
                    lat: p.lat,
                    lon: p.lon,
                    elevation: p.elevation || 0
                };

                if (prevPoint) {
                    const d = L.latLng(prevPoint.lat, prevPoint.lon)
                        .distanceTo(L.latLng(point.lat, point.lon));

                    cumulativeDistance += d;
                    point.distanceFromStart = cumulativeDistance;

                    const eleDiff = point.elevation - prevPoint.elevation;
                    point.slope = d > 0 ? (eleDiff / d) * 100 : 0;

                    slopeSum += point.slope;
                    slopeCount++;

                    if (eleDiff > 0) cumulativeAscent += eleDiff;
                    if (eleDiff < 0) cumulativeDescent += Math.abs(eleDiff);

                    point.cumulativeAscent = cumulativeAscent;
                    point.cumulativeDescent = cumulativeDescent;
                } else {
                    point.distanceFromStart = 0;
                    point.slope = 0;
                    point.cumulativeAscent = 0;
                    point.cumulativeDescent = 0;
                }

                minElevation = Math.min(minElevation, point.elevation);
                maxElevation = Math.max(maxElevation, point.elevation);

                trackPoints.push(point);
                prevPoint = point;
            });
        });

        // STATIC STATS
        document.getElementById('total-distance').textContent =
            `Total Distance: ${(cumulativeDistance / 1000).toFixed(2)} km`;
        document.getElementById('total-ascent').textContent =
            `Total Ascent: ${cumulativeAscent.toFixed(0)} m`;
        document.getElementById('total-descent').textContent =
            `Total Descent: ${cumulativeDescent.toFixed(0)} m`;
        document.getElementById('min-elevation').textContent =
            `Min Elevation: ${minElevation.toFixed(0)} m`;
        document.getElementById('max-elevation').textContent =
            `Max Elevation: ${maxElevation.toFixed(0)} m`;
        document.getElementById('avg-slope').textContent =
            `Average Slope: ${(slopeCount ? slopeSum / slopeCount : 0).toFixed(2)} %`;

        // MAP
        polyline = L.polyline(trackPoints.map(p => [p.lat, p.lon]), {
            color: 'red',
            weight: 4
        }).addTo(map);

        map.fitBounds(polyline.getBounds());

        hoverMarker = L.circleMarker([0, 0], {
            radius: 6,
            color: 'blue',
            fillColor: 'cyan',
            fillOpacity: 0.7
        }).addTo(map);

        // CHART
        const distances = trackPoints.map(p => Math.ceil(p.distanceFromStart/50)*50);
        const elevations = trackPoints.map(p => p.elevation.toFixed(1));

        const ctx = document.getElementById('elevationChart').getContext('2d');
        elevationChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: distances,
                datasets: [{
                    label: 'Elevation (m)',
                    data: elevations,
                    borderColor: 'green',
                    backgroundColor: 'rgba(0,128,0,0.2)',
                    fill: true,
                    tension: 0.2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    x: { title: { display: true, text: 'Distance (m)' } },
                    y: { title: { display: true, text: 'Elevation (m)' } }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: ctx => {
                                const p = trackPoints[ctx.dataIndex];
                                return [
                                    `Elevation: ${p.elevation.toFixed(1)} m`,
                                    `Slope: ${p.slope.toFixed(2)} %`,
                                    `Distance: ${(p.distanceFromStart / 1000).toFixed(2)} m`
                                ];
                            }
                        }
                    }
                },
                animation: false
            }
        });

        elevationChart.canvas.addEventListener('mousemove', evt => {
            const pts = elevationChart.getElementsAtEventForMode(
                evt, 'nearest', { intersect: false }, true
            );
            if (pts.length) {
                const p = trackPoints[pts[0].index];
                hoverMarker.setLatLng([p.lat, p.lon]);
            }
        });
    });
}


document.getElementById('route').addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => loadGpxFromText(reader.result);
    reader.readAsText(file);
});


fetch("{{ url_for('static', filename='route.gpx') }}")
    .then(r => r.text())
    .then(loadGpxFromText);
</script>

</body>
</html>
