<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GPX Viewer with Track Stats</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css"/>
<style>
html, body { margin:0; height:100%; font-family: Arial,sans-serif; }
#map { height: 50%; width: 100%; }
#stats { height: 15%; padding: 10px; background: #f5f5f5; }
#stats p { margin:5px 0; font-size: 12px;  }
#chart-container { height: 35%; width: 100%; padding: 10px; box-sizing: border-box; }
</style>
</head>
<body>

<div id="map"></div>
<div id="stats">
  <p id="total-distance">Total Distance: </p>
  <p id="total-ascent">Total Ascent: </p>
  <p id="total-descent">Total Descent: </p>
  <p id="min-elevation">Min Elevation: </p>
  <p id="max-elevation">Max Elevation: </p>
  <p id="avg-slope">Average Slope: </p>
</div>
<div id="chart-container">
  <canvas id="elevationChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gpx-parse@0.10.4/dist/gpx-parse-browser.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

<script>
const map = L.map('map').setView([0,0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap' }).addTo(map);

fetch("{{ url_for('static', filename='route.gpx') }}")
.then(res => res.text())
.then(gpxText => {
    gpxParse.parseGpx(gpxText, function(error, data) {
        if (error) { console.error(error); return; }
        if (!data.tracks || data.tracks.length === 0) return;

        const track = data.tracks[0];
        let trackPoints = [];
        let cumulativeDistance = 0;
        let cumulativeAscent = 0;
        let cumulativeDescent = 0;
        let minElevation = Infinity;
        let maxElevation = -Infinity;
        let slopeSum = 0;
        let slopeCount = 0;
        let prevPoint = null;

        track.segments.forEach(segment => {
            segment.forEach(p => {
                const point = { lat: p.lat, lon: p.lon, elevation: p.elevation || 0 };
                if (prevPoint) {
                    const d = L.latLng(prevPoint.lat, prevPoint.lon).distanceTo(L.latLng(p.lat, p.lon));
                    cumulativeDistance += d;
                    point.distanceFromStart = cumulativeDistance;

                    const eleDiff = point.elevation - prevPoint.elevation;
                    point.slope = d > 0 ? (eleDiff / d) * 100 : 0;

                    slopeSum += point.slope;
                    slopeCount++;

                    if (eleDiff > 0) cumulativeAscent += eleDiff;
                    if (eleDiff < 0) cumulativeDescent += Math.abs(eleDiff);

                    point.cumulativeAscent = cumulativeAscent;
                    point.cumulativeDescent = cumulativeDescent;
                } else {
                    point.distanceFromStart = 0;
                    point.slope = 0;
                    point.cumulativeAscent = 0;
                    point.cumulativeDescent = 0;
                }

                minElevation = Math.min(minElevation, point.elevation);
                maxElevation = Math.max(maxElevation, point.elevation);

                trackPoints.push(point);
                prevPoint = point;
            });
        });

        // Update static track stats
        document.getElementById('total-distance').textContent = `Total Distance: ${(cumulativeDistance/1000).toFixed(2)} km`;
        document.getElementById('total-ascent').textContent = `Total Ascent: ${cumulativeAscent.toFixed(1)} m`;
        document.getElementById('total-descent').textContent = `Total Descent: ${cumulativeDescent.toFixed(1)} m`;
        document.getElementById('min-elevation').textContent = `Min Elevation: ${minElevation.toFixed(1)} m`;
        document.getElementById('max-elevation').textContent = `Max Elevation: ${maxElevation.toFixed(1)} m`;
        document.getElementById('avg-slope').textContent = `Average Slope: ${(slopeCount > 0 ? slopeSum/slopeCount : 0).toFixed(2)} %`;

        // Draw polyline
        const polyline = L.polyline(trackPoints.map(p => [p.lat, p.lon]), { color: 'red', weight: 4 }).addTo(map);
        map.fitBounds(polyline.getBounds());

        // Hover marker
        const hoverMarker = L.circleMarker([0,0], { radius: 6, color: 'blue', fillColor: 'cyan', fillOpacity: 0.7 }).addTo(map);

        // Chart
        const distances = trackPoints.map(p => p.distanceFromStart.toFixed(1));
        const elevations = trackPoints.map(p => p.elevation.toFixed(1));
        const ctx = document.getElementById('elevationChart').getContext('2d');
        const elevationChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: distances,
                datasets: [{
                    label: 'Elevation (m)',
                    data: elevations,
                    borderColor: 'green',
                    backgroundColor: 'rgba(0,128,0,0.2)',
                    fill: true,
                    tension: 0.2,
                    borderWidth: 2,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                scales: {
                    x: { title: { display: true, text: 'Distance (m)' } },
                    y: { title: { display: true, text: 'Elevation (m)' } }
                },
                plugins: {
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(context) {
                                const idx = context.dataIndex;
                                const p = trackPoints[idx];
                                return [
                                    `Elevation: ${p.elevation.toFixed(1)} m`,
                                    `Slope: ${p.slope.toFixed(2)} %`,
                                    `Ascent: ${p.cumulativeAscent.toFixed(1)} m`,
                                    `Descent: ${p.cumulativeDescent.toFixed(1)} m`,
                                    `Distance: ${p.distanceFromStart.toFixed(1)} m`
                                ];
                            }
                        }
                    }
                },
                animation: false
            }
        });

        // Hover updates marker but not stats div (stats remain static)
        elevationChart.canvas.addEventListener('mousemove', function(evt) {
            const points = elevationChart.getElementsAtEventForMode(evt, 'nearest', { intersect: false }, true);
            if (points.length) {
                const idx = points[0].index;
                const p = trackPoints[idx];
                hoverMarker.setLatLng([p.lat, p.lon]);
            }
        });
    });
});
</script>
</body>
</html>
